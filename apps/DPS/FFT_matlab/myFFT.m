% FFT 快速傅里叶变换
% 可以补零计算的版本，原始序列长度将补长为2^N再计算
% 
% 使用MATLAB内建函数fft计算可以发现该方法和原长度的DFT之间计算有误差
% 
% 请参考《《数字信号处理：基于计算机的方法（第4版）》Sanjit K. Mitra》的相关内容：
% P440 11.2.3节 库利-图基FFT算法
% P449 11.4节 基于序号映射的快速DFT算法（意思就是补零）

clear;clc;

x0=input('输入需要FFT变换的原序列：');%输入原始序列
N0=length(x0);%计算原始序列的长度
%-------------------------------------------------------------
% 加长补零
M=nextpow2(N0);%?求x的长度对应的2的最低幂次m?, nextpow2就是求靠的最近的2的指数，比如数1000，那么靠的最近的（且比他大的）数就是1024=2^10，然后得到10?
N=2^M;
if length(x0) < N
    x = [x0,zeros(1,N-length(x0))];%?若x的长度不是2的幂，补零到2的整数幂
else
    x = x0;
end
%---------------------------------------------------------------
% 倒位序
a = (1:2^M)';
n0 = permute(reshape(a,2*ones(1,M)),M:-1:1);% M在该变换中表示维度，n是变换下标的中间产物的,permute用于维度交换，reshape功能是矩阵整形
n=n0(:).';% n是长度为N的行向量，其值就是变换后的下标

y=x(n(1:1:N));%?将x倒序后的排列赋值给y ，y的长度仍然是N
%---------------------------------------------------------------
WN=exp(-1i*2*pi/N);
for L=1:M % 计算分为M级
    B=2^L/2;%第L级中，每个蝶形的两个输入数据相距B个点，每级有B个不同的旋转因子?
    for J=0:B-1%?J代表了不同的旋转因子
       p=J*2^(M-L);
       WNp=WN^p;
       for k=J+1:2^L:N %?本次蝶形运算的跨越间隔为2^L
       kp=k+B; %?蝶形运算的两个因子对应单元下标的关系
       t=y(kp)*WNp; %?蝶形运算的乘积项
       y(kp)=y(k)-t; %?蝶形运算，注意必须先进行减法运算，然后进行加法运算，否则要使用中间变量来传递y(k)
       y(k)=y(k)+t; %?蝶形运算
       end
    end
end
disp('补零加长后的FFT计算结果：');
disp(y)

