% FFT 快速傅里叶变换
% 库利-图基FFT算法的一般形式对上述方法有所改进，但改进的方法仍然有条件，
% 即要求序列长度N可以表示成两个整数N1和N2的乘积，N=N1*N2
% 其核心任然是序号映射以及分级与组合运算；对于长度为质数序列的分解是值得思考的问题，
% 初步的想法是表示为1乘以N。

clear; clc;
x0=input('输入需要FFT变换的原序列：');%输入原始序列
 
%-------------------------------------------------
% 将数分解为两个最相近的因数
 
N=length(x0);% 输入序列x0的长度分解为两个整数
Len=fix(sqrt(N));
b=Len:-1:1;
 
while mod(N,b(1))
    if mod(N,b(1))%如果a不被b(1)整除，b(1)初始值为2
        b(~mod(b,b(1)))=[];%意思就是把b中能被b(1)整除的那些元素都删了。
                           %因为那些都不是素数，除了b(1)，但b(1)又不被a整除，即不是a的因子，所以也删掉。 
        continue; % 结束本次循环，进入下一次循环
    end
end
N1=b(1);
N2=N/b(1);% 计算和b(1)对应的因子
%-------------------------------------------------
WN=exp(-1i*2*pi/N);
WN1=exp(-1i*2*pi/N1);
WN2=exp(-1i*2*pi/N2);%定义旋转因子
G_n1k2=zeros(N1,N2);%定义N1×N2的全零矩阵
for n1=1:1:N1
    for k2=1:1:N2  
        G_n1k2_reg=0;
        for n2=1:1:N2
        G_n1k2_reg=G_n1k2_reg+x0((n1-1)+N1*(n2-1)+1)*WN2^((n2-1)*(k2-1));
        end
        G_n1k2(n1,k2)=G_n1k2_reg;
    end
end
%----------------------------------------------------
% 序列G(n1,k2)乘以旋转因子得到Gp(n1,k2)
n1k2=(0:1:N1-1)'*(0:1:N2-1);
Gp=G_n1k2.*(WN.^n1k2);
%----------------------------------------------------
% 由Gp矩阵计算出最后的结果
X=zeros(1,N);
for k1=1:1:N1
    for k2=1:1:N2
        X_k1k2_reg=0;
        for n1=1:1:N1
        X_k1k2_reg=X_k1k2_reg+Gp(n1,k2)*WN1^((n1-1)*(k1-1));
        end
        m=N2*(k1-1)+(k2-1)+1;
        X(m)=X_k1k2_reg;
    end
end
disp('一般形式的库利-图基FFT算法计算的结果：');
disp(X);
